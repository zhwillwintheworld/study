# 基础排序

## 引题：为什么插入排序比冒泡排序更受欢迎？

排序对于程序来说是非常重要的，例如数组排序，数据库排序，排序有很多算法，例如冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。

![img](https://static001.geekbang.org/resource/image/fb/cd/fb8394a588b12ff6695cfd664afb17cd.jpg)

既然冒泡和插入排序的时间复杂度都是O(n²)，为什么插入排序用的比冒泡排序用的更多呢？

## 分析一个排序算法

#### 算法的执行效率

1. **最好情况、最坏情况、平均情况时间复杂度**：为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道排序算法在不同数据下的性能表现。
2. **时间复杂度的系数、常数 、低阶**：我们知道，时间复杂度反应的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。
3. **比较次数和交换（或移动）次数**：基于比较的排序算法的执行过程，会涉及两种操作，一种是元素比较大小，另一种是元素交换或移动。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去。

#### 排序算法的内存消耗

算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。

#### 排序算法的稳定性

仅仅用执行效率和内存消耗来衡量排序算法的好坏是不够的。针对排序算法，我们还有一个重要的度量指标，稳定性。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。我通过一个例子来解释一下。比如我们有一组数据 2，9，3，4，8，3，按照大小排序之后就是 2，3，3，4，8，9。这组数据里有两个 3。经过某种排序算法排序之后，如果两个 3 的前后顺序没有改变，那我们就把这种排序算法叫作**稳定的排序算法**；如果前后顺序发生变化，那对应的排序算法就叫作**不稳定的排序算法**。

#### 算法稳定性的引用

例如数据库排序，一批订单基于金额排序，当金额一致时基于创建时间排序，这个时候我们就可以先对订单的创建时间排序，再利用稳定的排序算法对已经时间排序过的订单进行金额排序，由于稳定的排序算法，相同金额下，订单创建时间的顺序是一致的（即按照金额排序后与之前的元素顺序关系不变--不是全部元素，是单个元素与单个元素之间）

#### 有序度

**有序度是数组中具有有序关系的元素对的个数**

![img](https://static001.geekbang.org/resource/image/a1/20/a1ef4cc1999d6bd0af08d8417ee55220.jpg)

#### 满有序度

**同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 n*(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作满有序度**

#### 逆序度

**逆序度 = 满有序度 - 有序度**

#### 逆序度与比较交换排序算法

冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为逆序度，也就是n*(n-1)/2–初始有序度。此例中就是 15–3=12，要进行 12 次交换操作。

## 冒泡排序

冒泡排序的原理是元素左右进行比较，这样可以把最大的值搬运到数组最右端，然后依次遍历，最小的值在最左端

```java
 public static void  bubbleSort(int[] target){
        if(target==null){
            return;
        }
        int temp;
        for (int i = 0; i <target.length ; i++) {
            boolean flag=false; //如果不发生交换代表已排序完成，中止遍历
            for (int j = 0; j <target.length-i-1 ; j++) {
                if(target[j]>target[j+1]){
                    temp=target[j];
                    target[j]=target[j+1];
                    target[j+1]=temp;
                    flag=true;
                }
            }
            if(!flag){
                break;;
            }
        }
    }
```

**冒泡排序是一种原地排序算法，稳定的排序算法，最好时间复杂度为一次冒泡不做搬运时间复杂度为O(n),最差时间复杂度为每次冒泡都需要搬运O(n²)，平均时间复杂度为O(n²)**

## 插入排序

插入排序的原理是把数组第n个位置的元素与第n以前的元素进行对比，如果比n钱的某些元素小，则其他元素顺延一位，这个元素补到应该去的位置，就像插入有序数组一样

```java
public static void insertSort(int[] target){
  if(target==null){
    return ;
  }
  int j,value;
  for(int i=1;i<target.length;i++){
    j=i-1;
    value=target[i];
    for(;j>=0;j--){
      if(target[j]<value){
        target[j+1]=target[j];
      }else{
        break;
      }
    }
    target[j+1]=value;
  }
}
```

**插入排序是一种原地排序算法，也是稳定的排序算法--因为我们设定同值不发生交换，插入排序的最好时间复杂度为O(n),最差时间复杂度为O(n²)，平均时间复杂度为O(n²)；而插入排序比冒泡排序更受欢迎的原因是因为都是比较互换，那么两种算法的逆序度都是一样的，而插入排序的互换操作比冒泡排序的互换更简单。所以更节省时间。**

## 选择排序

选择排序的原理就是每次从未排序的区域中选取最小的那个元素放到已排序的末尾

```java
public static void selectSort(int[] target){
  if(target==null){
    return;
  }
  int value,index;
  for(int i=0;i<target.length;i++){
    index=i;
    value=target[i];
    boolean flag=false;
    for(int j=1;j<target.length-i;j++){
      if(target[i+j]<target[index]){
        index=i+j;
        flag=true
      }
    }
    if(flag){
      target[i]=target[index];
      target[index]=value;
    }
  }
}
```

**选择排序时一种原地排序算法，但因为不是逐个比较互换，破坏了稳定性，选择排序不是稳定的排序算法--（比如 5，8，5，2，9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。正是因此，相对于冒泡排序和插入排序，选择排序就稍微逊色了。）选择排序的最好，最差，平均时间复杂度都为O(n²)**

## 归并排序

前面三种都是O(n²)复杂度的排序算法，基于比较，实现思路简单，但是由于复杂度关系，只适用于少量的数据排序，不符合我们日常碰到的场景，所以需要一些更复杂，效率更好的算法来实现我们的需求，归并排序就是其中之一，归并排序根据名字可知，其核心思想是递归与合并，归并的最好，最差，平均时间复杂度为O(nlogn)

```java
public static void mergeSort(int[] target,int start,int end){
  if(start<end){
    int mid=(start+end)/2;
    mergeSort(target,start,mid);
    mergeSort(target,mid+1,end);
    merge(target,start,mid,end);
  }
}
public static void merge(int[] target,int start,int mid,int end){
  int length=end-start+1;//确定新创建的数组长度
  int temp=new int[length];
  int i=start;
  int j=mid+1;
  int index=0;
  while(i<=mid&&j<=end){
    if(target[i]<=target[j]){ //保证算法稳定性
      temp[index++]=target[i++]; 
    }else{
      temp[index++]=target[j++];
    }
  }
  int last=mid-i<0?j:i;
  while(index<length){
    temp[index++]=target[last++];
  }
  for(int k=0;k<length;k++){
    target[start+k]=temp[k];
  }
}
```

**归并排序由两部分组成，分治与合并，分治是一种算法思想，而用到的算法技巧就是递归，我们使用递归将数组分成2n部分，直到每个部分只有一个元素，这样就到了递归中止条件，由于系统压栈，所以系统会将只有一个元素的两个数组进行合并，合并的时候进行排序（由于我们使用了target[i]<=target[j]）这样就能保证算法稳定性，然后系统出栈，含有多个元素的两个数组继续合并，这样我们合并成功一个完整的原来数组，并且已排序，由于递归的时间复杂度是O(logn),但是合并中我们申请了其他空间，最大为n，所以归并算法的空间复杂度为O(n),所以归并算法并不是原地排序算法，而且，在合并过程中，我们也需要其他的操作，例如排序，重新塞入数组，所以时间复杂度为O(n),所以归并算法的最差，最好，平均时间复杂度都为O(nlogn)**

